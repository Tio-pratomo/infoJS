---
title: Real-World Application(E-Commerce Shop)
---

import { FileTree } from '@astrojs/starlight/components';

Selamat datang di sesi final! Kini saatnya menggabungkan **semua konsep** dari 9 sesi sebelumnya ke dalam satu aplikasi real-world: **Mini E-Commerce Shop**. Aplikasi ini akan mendemonstrasikan signals, SSE, CRUD, animations, file upload, security, dan performance optimization dalam satu ecosystem yang terintegrasi.

## Fitur Aplikasi E-Commerce

Aplikasi ini akan memiliki fitur-fitur berikut:

### Customer Features

- üõçÔ∏è **Product Catalog**: Browse produk dengan search dan filter
- üõí **Shopping Cart**: Add/remove items dengan real-time updates
- üí≥ **Checkout**: Form checkout dengan validasi
- üì¶ **Order Tracking**: Track status pesanan real-time via SSE
- üë§ **Authentication**: Register, login, dan profile management

### Admin Features

- ‚ûï **Product Management**: CRUD operations untuk produk
- üì∏ **Image Upload**: Upload gambar produk dengan preview
- üìä **Dashboard**: Real-time statistics (orders, revenue, inventory)
- üîî **Notifications**: SSE notifications untuk order baru

## Struktur Project

<FileTree>

- ecommerce-shop/
  - server.js # Main Express server
  - db.js # In-memory database
  - middleware/
    - auth.js # JWT authentication
    - validation.js # Input validation schemas
  - public/
    - index.html # Customer storefront
    - admin.html # Admin dashboard
    - cart.html # Shopping cart page
    - checkout.html # Checkout page
  - uploads/ # Product images
  - .env # Environment variables
  - package.json

</FileTree>

## Backend Implementation

### Setup & Dependencies

**`package.json`:**

```json
{
  "name": "ecommerce-datastar",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "multer": "^1.4.5-lts.1",
    "joi": "^17.11.0",
    "dotenv": "^16.3.1",
    "helmet": "^7.1.0",
    "express-rate-limit": "^7.1.5",
    "cookie-parser": "^1.4.6",
    "csurf": "^1.11.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
```

### Database Schema (In-Memory)

**`db.js`:**

```js
// Simulasi database in-memory untuk demo
// Dalam production, gunakan PostgreSQL, MongoDB, dll.

export const db = {
  users: [
    {
      id: 1,
      username: 'admin',
      email: 'admin@shop.com',
      // Password: admin123 (hashed)
      password: '$2a$10$YourHashedPasswordHere',
      role: 'admin',
      createdAt: new Date(),
    },
  ],

  products: [
    {
      id: 1,
      name: 'Laptop Gaming ROG',
      description: 'Laptop gaming performa tinggi dengan RTX 4060',
      price: 15000000,
      stock: 10,
      category: 'Electronics',
      image: '/uploads/laptop.jpg',
      createdAt: new Date(),
    },
    {
      id: 2,
      name: 'Mouse Wireless Logitech',
      description: 'Mouse ergonomis dengan battery 6 bulan',
      price: 350000,
      stock: 25,
      category: 'Accessories',
      image: '/uploads/mouse.jpg',
      createdAt: new Date(),
    },
    {
      id: 3,
      name: 'Mechanical Keyboard',
      description: 'Keyboard mechanical RGB dengan switch blue',
      price: 750000,
      stock: 15,
      category: 'Accessories',
      image: '/uploads/keyboard.jpg',
      createdAt: new Date(),
    },
  ],

  carts: [], // { userId, items: [{ productId, quantity }], createdAt, updatedAt }

  orders: [], // { id, userId, items, total, status, createdAt }

  // Counters
  nextUserId: 2,
  nextProductId: 4,
  nextOrderId: 1,
};

// Helper functions
export function findUserByUsername(username) {
  return db.users.find((u) => u.username === username);
}

export function findUserById(id) {
  return db.users.find((u) => u.id === id);
}

export function findProductById(id) {
  return db.products.find((p) => p.id === id);
}

export function getCart(userId) {
  let cart = db.carts.find((c) => c.userId === userId);
  if (!cart) {
    cart = { userId, items: [], createdAt: new Date(), updatedAt: new Date() };
    db.carts.push(cart);
  }
  return cart;
}

export function updateCartItem(userId, productId, quantity) {
  const cart = getCart(userId);
  const existingItem = cart.items.find((i) => i.productId === productId);

  if (existingItem) {
    if (quantity <= 0) {
      // Remove item
      cart.items = cart.items.filter((i) => i.productId !== productId);
    } else {
      // Update quantity
      existingItem.quantity = quantity;
    }
  } else if (quantity > 0) {
    // Add new item
    cart.items.push({ productId, quantity });
  }

  cart.updatedAt = new Date();
  return cart;
}

export function clearCart(userId) {
  const cart = getCart(userId);
  cart.items = [];
  cart.updatedAt = new Date();
}

export function calculateCartTotal(cart) {
  return cart.items.reduce((total, item) => {
    const product = findProductById(item.productId);
    return total + (product ? product.price * item.quantity : 0);
  }, 0);
}
```

### Main Server

**`server.js`:**

```js
import express from 'express';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import cookieParser from 'cookie-parser';

import {
  db,
  findUserByUsername,
  findUserById,
  findProductById,
  getCart,
  updateCartItem,
  clearCart,
  calculateCartTotal,
} from './db.js';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3000;
const JWT_SECRET = process.env.JWT_SECRET || 'change-me-in-production';

// Middleware
app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        scriptSrc: ["'self'", "'unsafe-inline'", 'https://cdn.jsdelivr.net'],
        styleSrc: ["'self'", "'unsafe-inline'"],
        imgSrc: ["'self'", 'data:', 'https:'],
      },
    },
  })
);

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());
app.use(express.static('public'));
app.use('/uploads', express.static('uploads'));

// Ensure uploads directory exists
const uploadsDir = path.join(__dirname, 'uploads');
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100,
  message: 'Too many requests from this IP',
});
app.use('/api/', limiter);

// Multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadsDir),
  filename: (req, file, cb) => {
    const uniqueName = `${Date.now()}-${file.originalname}`;
    cb(null, uniqueName);
  },
});

const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type'), false);
    }
  },
});

// Auth middleware
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ');

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ error: 'Invalid token' });
    req.user = user;
    next();
  });
}

function requireRole(role) {
  return (req, res, next) => {
    if (req.user.role !== role) {
      return res.status(403).json({ error: 'Access denied' });
    }
    next();
  };
}

// ===== AUTH ENDPOINTS =====

app.post('/api/register', async (req, res) => {
  const { username, email, password } = req.body;

  if (!username || !email || !password) {
    return res.status(400).json({ error: 'All fields required' });
  }

  if (findUserByUsername(username)) {
    return res.status(400).json({ error: 'Username already exists' });
  }

  const hashedPassword = await bcrypt.hash(password, 10);
  const user = {
    id: db.nextUserId++,
    username,
    email,
    password: hashedPassword,
    role: 'customer',
    createdAt: new Date(),
  };
  db.users.push(user);

  res.json({ success: true, message: 'Registration successful' });
});

app.post('/api/login', async (req, res) => {
  const { username, password } = req.body;

  const user = findUserByUsername(username);
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  const validPassword = await bcrypt.compare(password, user.password);
  if (!validPassword) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  const token = jwt.sign({ id: user.id, username: user.username, role: user.role }, JWT_SECRET, {
    expiresIn: '24h',
  });

  res.json({
    success: true,
    token,
    user: { id: user.id, username: user.username, role: user.role },
  });
});

// ===== PRODUCT ENDPOINTS =====

app.get('/api/products', (req, res) => {
  const { search, category } = req.query;
  let products = [...db.products];

  if (search) {
    const searchLower = search.toLowerCase();
    products = products.filter(
      (p) =>
        p.name.toLowerCase().includes(searchLower) ||
        p.description.toLowerCase().includes(searchLower)
    );
  }

  if (category && category !== 'all') {
    products = products.filter((p) => p.category === category);
  }

  res.json({ products });
});

app.get('/api/products/:id', (req, res) => {
  const product = findProductById(Number(req.params.id));
  if (!product) {
    return res.status(404).json({ error: 'Product not found' });
  }
  res.json({ product });
});

app.post(
  '/api/products',
  authenticateToken,
  requireRole('admin'),
  upload.single('image'),
  (req, res) => {
    const { name, description, price, stock, category } = req.body;

    const product = {
      id: db.nextProductId++,
      name,
      description,
      price: Number(price),
      stock: Number(stock),
      category,
      image: req.file ? `/uploads/${req.file.filename}` : '/uploads/default.jpg',
      createdAt: new Date(),
    };

    db.products.push(product);

    res.json({ success: true, product });
  }
);

app.put('/api/products/:id', authenticateToken, requireRole('admin'), (req, res) => {
  const product = findProductById(Number(req.params.id));
  if (!product) {
    return res.status(404).json({ error: 'Product not found' });
  }

  const { name, description, price, stock, category } = req.body;
  Object.assign(product, {
    name,
    description,
    price: Number(price),
    stock: Number(stock),
    category,
  });

  res.json({ success: true, product });
});

app.delete('/api/products/:id', authenticateToken, requireRole('admin'), (req, res) => {
  const index = db.products.findIndex((p) => p.id === Number(req.params.id));
  if (index === -1) {
    return res.status(404).json({ error: 'Product not found' });
  }

  db.products.splice(index, 1);
  res.json({ success: true });
});

// ===== CART ENDPOINTS =====

app.get('/api/cart', authenticateToken, (req, res) => {
  const cart = getCart(req.user.id);
  const cartWithDetails = {
    ...cart,
    items: cart.items.map((item) => {
      const product = findProductById(item.productId);
      return { ...item, product };
    }),
    total: calculateCartTotal(cart),
  };

  res.json({ cart: cartWithDetails });
});

app.post('/api/cart', authenticateToken, (req, res) => {
  const { productId, quantity } = req.body;

  const product = findProductById(productId);
  if (!product) {
    return res.status(404).json({ error: 'Product not found' });
  }

  if (quantity > product.stock) {
    return res.status(400).json({ error: 'Insufficient stock' });
  }

  const cart = updateCartItem(req.user.id, productId, quantity);
  const total = calculateCartTotal(cart);

  res.json({ success: true, cart, total });
});

app.delete('/api/cart/:productId', authenticateToken, (req, res) => {
  const cart = updateCartItem(req.user.id, Number(req.params.productId), 0);
  const total = calculateCartTotal(cart);

  res.json({ success: true, cart, total });
});

// ===== ORDER ENDPOINTS =====

app.post('/api/orders', authenticateToken, (req, res) => {
  const cart = getCart(req.user.id);

  if (cart.items.length === 0) {
    return res.status(400).json({ error: 'Cart is empty' });
  }

  // Validate stock
  for (const item of cart.items) {
    const product = findProductById(item.productId);
    if (product.stock < item.quantity) {
      return res.status(400).json({
        error: `Insufficient stock for ${product.name}`,
      });
    }
  }

  // Decrease stock
  cart.items.forEach((item) => {
    const product = findProductById(item.productId);
    product.stock -= item.quantity;
  });

  const order = {
    id: db.nextOrderId++,
    userId: req.user.id,
    items: cart.items.map((item) => ({
      productId: item.productId,
      quantity: item.quantity,
      price: findProductById(item.productId).price,
    })),
    total: calculateCartTotal(cart),
    status: 'pending',
    createdAt: new Date(),
  };

  db.orders.push(order);
  clearCart(req.user.id);

  // Broadcast to admin via SSE (implemented below)
  broadcastToAdmins({ type: 'new_order', order });

  res.json({ success: true, order });
});

app.get('/api/orders', authenticateToken, (req, res) => {
  const orders = db.orders
    .filter((o) => req.user.role === 'admin' || o.userId === req.user.id)
    .map((order) => ({
      ...order,
      items: order.items.map((item) => ({
        ...item,
        product: findProductById(item.productId),
      })),
    }));

  res.json({ orders });
});

// ===== SSE FOR REAL-TIME UPDATES =====

const sseClients = new Set();

app.get('/api/sse/admin', authenticateToken, requireRole('admin'), (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  const client = { res, userId: req.user.id };
  sseClients.add(client);

  // Send initial connection
  res.write(`data: ${JSON.stringify({ type: 'connected' })}\n\n`);

  req.on('close', () => {
    sseClients.delete(client);
  });
});

function broadcastToAdmins(data) {
  sseClients.forEach((client) => {
    client.res.write(`data: ${JSON.stringify(data)}\n\n`);
  });
}

// Start server
app.listen(PORT, () => {
  console.log(`üöÄ E-Commerce server running on http://localhost:${PORT}`);
  console.log(`üì¶ Products: ${db.products.length}`);
  console.log(`üë§ Users: ${db.users.length}`);
});
```

## Frontend Implementation

### Customer Storefront

**`public/index.html`:**

```html
<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TechShop - E-Commerce</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Segoe UI', sans-serif;
        background: #f5f5f5;
      }

      header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px 0;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
      }

      nav {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .logo {
        font-size: 24px;
        font-weight: bold;
      }

      .cart-button {
        background: white;
        color: #667eea;
        padding: 10px 20px;
        border-radius: 6px;
        text-decoration: none;
        font-weight: 600;
      }

      .search-bar {
        margin: 30px 0;
        display: flex;
        gap: 10px;
      }

      .search-bar input {
        flex: 1;
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 6px;
        font-size: 14px;
      }

      .search-bar select {
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 6px;
      }

      .products-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .product-card {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        transition: transform 0.3s;
      }

      .product-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .product-image {
        width: 100%;
        height: 200px;
        object-fit: cover;
        border-radius: 6px;
        background: #f0f0f0;
      }

      .product-name {
        font-size: 18px;
        font-weight: 600;
        margin: 10px 0;
      }

      .product-price {
        color: #667eea;
        font-size: 20px;
        font-weight: bold;
      }

      .add-to-cart {
        width: 100%;
        padding: 10px;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        margin-top: 10px;
        font-weight: 600;
      }

      .add-to-cart:hover {
        background: #5568d3;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/@datastar/core@latest"></script>

    <div
      data-signals='{
        "products": [],
        "searchTerm": "",
        "category": "all",
        "token": "",
        "user": null
    }'
      data-persist="token:local"
    >
      <header>
        <div class="container">
          <nav>
            <div class="logo">üõçÔ∏è TechShop</div>
            <a href="/cart.html" class="cart-button"> üõí Cart </a>
          </nav>
        </div>
      </header>

      <div class="container">
        <div class="search-bar">
          <input
            type="text"
            data-bind-value="$searchTerm"
            data-on-input__debounce.300ms="@get('/api/products?search=' + encodeURIComponent($searchTerm) + '&category=' + $category)"
            placeholder="Search products..."
          />
          <select
            data-bind-value="$category"
            data-on-change="@get('/api/products?category=' + $category)"
          >
            <option value="all">All Categories</option>
            <option value="Electronics">Electronics</option>
            <option value="Accessories">Accessories</option>
          </select>
        </div>

        <div class="products-grid" id="products-grid">
          <!-- Products will be loaded here -->
        </div>
      </div>
    </div>

    <script>
      // Load products on page load
      window.addEventListener('load', async () => {
        const response = await fetch('/api/products');
        const data = await response.json();
        renderProducts(data.products);
      });

      function renderProducts(products) {
        const grid = document.getElementById('products-grid');
        grid.innerHTML = products
          .map(
            (p) => `
                <div class="product-card">
                    <img src="${p.image}" class="product-image" alt="${p.name}">
                    <div class="product-name">${p.name}</div>
                    <div class="product-price">Rp ${p.price.toLocaleString('id-ID')}</div>
                    <p style="color: #666; font-size: 14px; margin: 10px 0;">${p.description}</p>
                    <button class="add-to-cart" onclick="addToCart(${p.id})">
                        Add to Cart
                    </button>
                </div>
            `
          )
          .join('');
      }

      async function addToCart(productId) {
        const token = localStorage.getItem('token');
        if (!token) {
          alert('Please login first');
          window.location.href = '/login.html';
          return;
        }

        try {
          const response = await fetch('/api/cart', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify({ productId, quantity: 1 }),
          });

          if (response.ok) {
            alert('Added to cart!');
          } else {
            const data = await response.json();
            alert(data.error || 'Failed to add to cart');
          }
        } catch (error) {
          console.error('Error:', error);
        }
      }
    </script>
  </body>
</html>
```

## Key Features Implemented

### Dari 10 Sesi yang Sudah Dipelajari

**Sesi 1-2**: Signals untuk state management (products, cart, user)

**Sesi 3**: CRUD operations untuk products dan cart

**Sesi 4**: SSE untuk real-time admin notifications

**Sesi 5**: Click-to-edit patterns untuk admin dashboard

**Sesi 6**: Animations untuk cart updates dan product hover

**Sesi 7**: File upload untuk product images

**Sesi 8**: Debounce untuk search, performance optimization

**Sesi 9**: JWT auth, rate limiting, input validation

**Sesi 10**: Full integration semua konsep

## Kesimpulan: Perjalanan Datastar Selesai!

Selamat! Anda telah menyelesaikan **10 sesi komprehensif** pembelajaran Datastar dengan Node.js. Dari konsep dasar hingga aplikasi production-ready, Anda kini memiliki toolkit lengkap untuk membangun aplikasi web modern yang:

‚úÖ **Reaktif** dengan signals dan expressions
‚úÖ **Real-time** dengan Server-Sent Events  
‚úÖ **Aman** dengan CSRF, XSS protection, dan authentication
‚úÖ **Cepat** dengan debounce, caching, dan optimization
‚úÖ **Modern** dengan animations dan View Transitions
‚úÖ **Production-ready** dengan error handling dan monitoring

**Next Steps:**

- Deploy aplikasi ke production (Vercel, Railway, Fly.io)
- Integrasikan dengan database real (PostgreSQL, MongoDB)
- Tambahkan payment gateway (Stripe, Razorpay)
- Implementasikan email notifications
- Setup CI/CD pipeline

Selamat membangun aplikasi web yang luar biasa dengan Datastar! üöÄ
